#pragma once
#include "includes.h"

// No Reload Values
// Orignal
float originalReloadTime = 0.0f;
float originalReloadScale = 0.0f;
float originalChargeDownTime = 0.0f;
// No Recoil Values
// Orignal
float originalRecoilVert = 0.0f;
float originalRecoilHoriz = 0.0f;
float originalRecoilDownsightsMultiplier = 0.0f;
//
// No Spread Values
// Orignal
float originalSpread = 0.0f;
float originalSpreadDownsights = 0.0f;
float originalStandingStillSpreadMultiplier = 0.0f;
float originalAthenaJumpingFallingSpreadMultiplier = 0.0f;
float originalAthenaCrouchingSpreadMultiplier = 0.0f;
float originalAthenaSprintingSpreadMultiplier = 0.0f;
float originalMinSpeedForSpreadMultiplier = 0.0f;
float originalMaxSpeedForSpreadMultiplier = 0.0f;
//

PVOID localPlayerWeapon = 0;
PVOID(*ProcessEvent)(PVOID, PVOID, PVOID, PVOID) = nullptr;

static void Rapid(float time)
{
	uint64_t CurrentWeapon = 0;
	float i = 0;
	float c = 0;

	CurrentWeapon = *(uint64_t*)(LocalPawn + Offsets::FortniteGame::FortPawn::CurrentWeapon);

	if (CurrentWeapon) {
		i = *(float*)(CurrentWeapon + Offsets::FortniteGame::FortWeapon::LastFireTime);
		c = *(float*)(CurrentWeapon + Offsets::FortniteGame::FortWeapon::LastFireTimeVerified);
		*(float*)(CurrentWeapon + Offsets::FortniteGame::FortWeapon::LastFireTime) = i + c - time;

		return;
	}
}


VOID CalcAngle(float* src, float* dst, float* angles);
VOID ToMatrixWithScale(float* in, float out[4][4]);
VOID GetBoneLocation(float compMatrix[4][4], PVOID bones, DWORD index, float out[3]);

float Normalize(float angle) {
	float a = (float)fmod(fmod(angle, 360.0) + 360.0, 360.0);
	if (a > 180.0f) {
		a -= 360.0f;
	}
	return a;
}

VOID CalcAngle(float* src, float* dst, float* angles) {
	float rel[3] = {
		dst[0] - src[0],
		dst[1] - src[1],
		dst[2] - src[2],
	};

	auto dist = sqrtf(rel[0] * rel[0] + rel[1] * rel[1] + rel[2] * rel[2]);
	auto yaw = atan2f(rel[1], rel[0]) * (180.0f / PI);
	auto pitch = (-((acosf((rel[2] / dist)) * 180.0f / PI) - 90.0f));

	angles[0] = Normalize(pitch);
	angles[1] = Normalize(yaw);
}

VOID ToMatrixWithScale(float* in, float out[4][4])
{
	auto* rotation = &in[0];
	auto* translation = &in[4];
	auto* scale = &in[8];

	out[3][0] = translation[0];
	out[3][1] = translation[1];
	out[3][2] = translation[2];

	auto x2 = rotation[0] + rotation[0];
	auto y2 = rotation[1] + rotation[1];
	auto z2 = rotation[2] + rotation[2];

	auto xx2 = rotation[0] * x2;
	auto yy2 = rotation[1] * y2;
	auto zz2 = rotation[2] * z2;
	out[0][0] = (1.0f - (yy2 + zz2)) * scale[0];
	out[1][1] = (1.0f - (xx2 + zz2)) * scale[1];
	out[2][2] = (1.0f - (xx2 + yy2)) * scale[2];

	auto yz2 = rotation[1] * z2;
	auto wx2 = rotation[3] * x2;
	out[2][1] = (yz2 - wx2) * scale[2];
	out[1][2] = (yz2 + wx2) * scale[1];

	auto xy2 = rotation[0] * y2;
	auto wz2 = rotation[3] * z2;
	out[1][0] = (xy2 - wz2) * scale[1];
	out[0][1] = (xy2 + wz2) * scale[0];

	auto xz2 = rotation[0] * z2;
	auto wy2 = rotation[3] * y2;
	out[2][0] = (xz2 + wy2) * scale[2];
	out[0][2] = (xz2 - wy2) * scale[0];

	out[0][3] = 0.0f;
	out[1][3] = 0.0f;
	out[2][3] = 0.0f;
	out[3][3] = 1.0f;
}

VOID MultiplyMatrices(float a[4][4], float b[4][4], float out[4][4]) {
	for (auto r = 0; r < 4; ++r) {
		for (auto c = 0; c < 4; ++c) {
			auto sum = 0.0f;

			for (auto i = 0; i < 4; ++i) {
				sum += a[r][i] * b[i][c];
			}

			out[r][c] = sum;
		}
	}
}

VOID GetBoneLocation(float compMatrix[4][4], PVOID bones, DWORD index, float out[3]) {
	float boneMatrix[4][4];
	ToMatrixWithScale((float*)((PBYTE)bones + (index * 0x30)), boneMatrix);

	float result[4][4];
	MultiplyMatrices(boneMatrix, compMatrix, result);

	out[0] = result[3][0];
	out[1] = result[3][1];
	out[2] = result[3][2];
}

//if (!bones) bones = ReadPointer(mesh, 0x420 + 0x10);
BOOLEAN GetTarget(GetStructs::FVector& out) {
	if (!LocalPawn) {
		return FALSE;
	}
	if (!LocalPawn) {
		MessageBoxA(0, "pawna dead offset", 0, 0);
		return FALSE;
	}

	auto mesh = ReadPointer(LocalPawn, Offsets::Engine::Character::Mesh);
	if (!mesh) {
		MessageBoxA(0, "mesh dead offset", 0, 0);
		return FALSE;
	}

	auto bones = ReadPointer(mesh, 420);
	if (!bones) bones = ReadPointer(mesh, 420 + 0x10);
	if (!bones) {
		MessageBoxA(0, "bones dead offset", 0, 0);
		return FALSE;
	}

	float compMatrix[4][4] = { 0 };

	ToMatrixWithScale(reinterpret_cast<float*>(reinterpret_cast<PBYTE>(mesh) + 0x1C0), compMatrix);
	float kek[3];
	GetBoneLocation(compMatrix, bones, 66, kek);

	return TRUE;
}

PVOID ProcessEventHook(UObject* object, UObject* func, PVOID params, PVOID result) {
	if (object && func) {

		auto objectName = GetObjects::GetObjectFirstName(object);
		auto funcName = GetObjects::GetObjectFirstName(func);

		do {
			if (LocalPawn) {
				if (wcsstr(objectName.c_str(), L"B_Prj_Bullet_Sniper") && funcName == L"OnRep_FireStart" && bBulletTP) {
					GetStructs::FVector asd = { 0 };
					//Vector3 head = CalcAim();
					//asd.X - head.x;
					//asd.Y - head.y;
					//asd.Z - head.z;
					if (!GetTarget(asd)) {
						break;
					}
					*reinterpret_cast<GetStructs::FVector*>(reinterpret_cast<PBYTE>(object) + Offsets::FortniteGame::FortProjectileAthena::FireStartLoc) = asd;
					auto root = reinterpret_cast<PBYTE>(ReadPointer(object, Offsets::Engine::Actor::RootComponent));
					*reinterpret_cast<GetStructs::FVector*>(root + Offsets::Engine::SceneComponent::RelativeLocation) = asd;
					memset(root + Offsets::Engine::SceneComponent::ComponentVelocity, 0, sizeof(GetStructs::FVector));
				}
			}
		} while (FALSE);
	}
	return ProcessEvent(object, func, params, result);
}

void Exploits() {
	if (!LocalPawn) return;
	auto weaponName = GetObjects::GetObjectFirstName((UObject*)LocalWeapon);

	if (Spoofer::SpoofCall(GetAsyncKeyState, VK_LSHIFT & VK_SPACE) && bAirStruck) {
		*reinterpret_cast<float*>(reinterpret_cast<PBYTE>(LocalPawn) + Offsets::Engine::Actor::CustomTimeDilation) = 0;
	}
	else {
		*reinterpret_cast<float*>(reinterpret_cast<PBYTE>(LocalPawn) + Offsets::Engine::Actor::CustomTimeDilation) = 1;
	}

	if (bNoReload && LocalPawn) {

		static float last_fire_ability_time = 0.f;
		localPlayerWeapon = ReadPointer(LocalPawn, Offsets::FortniteGame::FortPawn::CurrentWeapon);
		auto stats = GetWeaponStats(localPlayerWeapon);

		auto& reloadTime = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::FortniteGame::FortBaseWeaponStats::ReloadTime);
		auto& ReloadScale = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::FortniteGame::FortBaseWeaponStats::ReloadScale);
		auto& ChargeDownTime = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::FortniteGame::FortBaseWeaponStats::ChargeDownTime);

		if (GetWeaponStats(localPlayerWeapon) != nullptr)
		{
			if (Spoofer::SpoofCall(GetAsyncKeyState, 'Q' & 0x0001)) {
				return;
			}
			if (stats) {
				if (reloadTime != 0.01f && *(float*)(LocalWeapon + Offsets::FortniteGame::FortWeapon::LastFireAbilityTime) == last_fire_ability_time) {
					last_fire_ability_time = *(float*)(LocalWeapon + Offsets::FortniteGame::FortWeapon::LastFireAbilityTime);
					originalReloadTime = reloadTime;
					originalReloadScale = ReloadScale;
					originalChargeDownTime = ChargeDownTime;

					reloadTime = 0.0f;
					ReloadScale = 0.0f;
					ChargeDownTime = 0.1f;
				}
				else if (reloadTime = 0.0f && *(float*)(LocalWeapon + Offsets::FortniteGame::FortWeapon::LastFireAbilityTime) != last_fire_ability_time) {
					{
						last_fire_ability_time = *(float*)(LocalWeapon + Offsets::FortniteGame::FortWeapon::LastFireAbilityTime);
						reloadTime = originalReloadTime;
						ReloadScale = originalReloadScale;
						ChargeDownTime = originalChargeDownTime;
						return;
					}
				}
			}
		}
	}

	/*if (bBoatSpeed)
	{
		if (LocalPawn)
		{
			*(float*)(Offsets::Engine::Level::AActors + Offsets::FortniteGame::FortMeatballVehicle::BoostMinPushForce) = (1200.0f * bBoatSpeedValue);
			*(float*)(Offsets::Engine::Level::AActors + Offsets::FortniteGame::FortMeatballVehicle::BoostTopSpeedForceMultiplier) = (1.3f * bBoatSpeedValue);
			*(float*)(Offsets::Engine::Level::AActors + Offsets::FortniteGame::FortMeatballVehicle::BoostTopSpeedMultiplier) = (1.3f * bBoatSpeedValue);
			*(float*)(Offsets::Engine::Level::AActors + Offsets::FortniteGame::FortMeatballVehicle::LandTopSpeedMultiplier) = (1.0f * bBoatSpeedValue);
			*(float*)(Offsets::Engine::Level::AActors + Offsets::FortniteGame::FortMeatballVehicle::LandPushForceMultiplier) = (3.0f * bBoatSpeedValue);
			*(float*)(Offsets::Engine::Level::AActors + Offsets::FortniteGame::FortMeatballVehicle::BoostSteeringMultiplier) = 1.0f;
			*(float*)(Offsets::Engine::Level::AActors + Offsets::FortniteGame::FortMeatballVehicle::LandSteeringMultiplier) = 1.0f;
			*(float*)(Offsets::Engine::Level::AActors + Offsets::FortniteGame::FortMeatballVehicle::LandMinSpeedSteeringAngle) = 180.0f;
			*(float*)(Offsets::Engine::Level::AActors + Offsets::FortniteGame::FortMeatballVehicle::LandMaxSpeedSteeringAngle) = 180.0f;
		}
	}
	else
	{
		if (LocalPawn)
		{
			*(float*)(Offsets::Engine::Level::AActors + Offsets::FortniteGame::FortMeatballVehicle::BoostMinPushForce) = 1200;
			*(float*)(Offsets::Engine::Level::AActors + Offsets::FortniteGame::FortMeatballVehicle::BoostTopSpeedForceMultiplier) = 1.29;
			*(float*)(Offsets::Engine::Level::AActors + Offsets::FortniteGame::FortMeatballVehicle::BoostTopSpeedMultiplier) = 1.29;
			*(float*)(Offsets::Engine::Level::AActors + Offsets::FortniteGame::FortMeatballVehicle::LandTopSpeedMultiplier) = 0.1;
			*(float*)(Offsets::Engine::Level::AActors + Offsets::FortniteGame::FortMeatballVehicle::LandPushForceMultiplier) = 3;
			*(float*)(Offsets::Engine::Level::AActors + Offsets::FortniteGame::FortMeatballVehicle::BoostSteeringMultiplier) = 0.2;
			*(float*)(Offsets::Engine::Level::AActors + Offsets::FortniteGame::FortMeatballVehicle::LandSteeringMultiplier) = 1;
			*(float*)(Offsets::Engine::Level::AActors + Offsets::FortniteGame::FortMeatballVehicle::LandMinSpeedSteeringAngle) = 180;
			*(float*)(Offsets::Engine::Level::AActors + Offsets::FortniteGame::FortMeatballVehicle::LandMaxSpeedSteeringAngle) = 25;
		}
	}*/

	if (bNoRecoil && LocalPawn) {

		static float last_fire_ability_time = 0.f;
		localPlayerWeapon = ReadPointer(LocalPawn, Offsets::FortniteGame::FortPawn::CurrentWeapon);
		auto stats = GetWeaponStats(localPlayerWeapon);

		auto& RecoilVert = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::FortniteGame::FortRangedWeaponStats::RecoilVert);
		auto& RecoilHoriz = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::FortniteGame::FortRangedWeaponStats::RecoilHoriz);
		auto& RecoilDownsightsMultiplier = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::FortniteGame::FortRangedWeaponStats::RecoilDownsightsMultiplier);

		if (GetWeaponStats(localPlayerWeapon) != nullptr)
		{
			if (Spoofer::SpoofCall(GetAsyncKeyState, 'Q' & 0x0001)) {
				return;
			}
			if (stats)
			{
				if (*(float*)(LocalWeapon + Offsets::FortniteGame::FortWeapon::LastFireAbilityTime) != last_fire_ability_time) {
					last_fire_ability_time = *(float*)(LocalWeapon + Offsets::FortniteGame::FortWeapon::LastFireAbilityTime);

					originalRecoilVert = RecoilVert;
					originalRecoilHoriz = RecoilHoriz;
					originalRecoilDownsightsMultiplier = RecoilDownsightsMultiplier;

					RecoilVert = 0.0f;
					RecoilHoriz = 0.0f;
					RecoilDownsightsMultiplier = 0.0f;

				}

			}
		}
		else if (*(float*)(LocalWeapon + Offsets::FortniteGame::FortWeapon::LastFireAbilityTime) == last_fire_ability_time) {
			last_fire_ability_time = *(float*)(LocalWeapon + Offsets::FortniteGame::FortWeapon::LastFireAbilityTime);

			RecoilVert = originalRecoilVert;
			RecoilHoriz = originalRecoilHoriz;
			RecoilDownsightsMultiplier = originalRecoilDownsightsMultiplier;
			return;
		}
	}

	if (bNoSpread && LocalPawn) {

		static float last_fire_ability_time = 0.f;
		localPlayerWeapon = ReadPointer(LocalPawn, Offsets::FortniteGame::FortPawn::CurrentWeapon);
		auto stats = GetWeaponStats(localPlayerWeapon);

		auto& Spread = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::FortniteGame::FortRangedWeaponStats::Spread);
		auto& SpreadDownsights = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::FortniteGame::FortRangedWeaponStats::SpreadDownsights);
		auto& StandingStillSpreadMultiplier = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::FortniteGame::FortRangedWeaponStats::StandingStillSpreadMultiplier);
		auto& AthenaJumpingFallingSpreadMultiplier = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::FortniteGame::FortRangedWeaponStats::AthenaJumpingFallingSpreadMultiplier);
		auto& AthenaCrouchingSpreadMultiplier = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::FortniteGame::FortRangedWeaponStats::AthenaCrouchingSpreadMultiplier);
		auto& AthenaSprintingSpreadMultiplier = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::FortniteGame::FortRangedWeaponStats::AthenaSprintingSpreadMultiplier);
		auto& MinSpeedForSpreadMultiplier = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::FortniteGame::FortRangedWeaponStats::MinSpeedForSpreadMultiplier);
		auto& MaxSpeedForSpreadMultiplier = *reinterpret_cast<float*>(reinterpret_cast<PBYTE>(stats) + Offsets::FortniteGame::FortRangedWeaponStats::MaxSpeedForSpreadMultiplier);

		if (GetWeaponStats(localPlayerWeapon) != nullptr)
		{
			if (Spoofer::SpoofCall(GetAsyncKeyState, 'Q' & 0x0001)) {
				return;
			}
			if (stats)
			{
				if (*(float*)(LocalWeapon + Offsets::FortniteGame::FortWeapon::LastFireAbilityTime) != last_fire_ability_time) {

					last_fire_ability_time = *(float*)(LocalWeapon + Offsets::FortniteGame::FortWeapon::LastFireAbilityTime);
					originalSpread = Spread;
					originalSpreadDownsights = SpreadDownsights;
					originalStandingStillSpreadMultiplier = StandingStillSpreadMultiplier;
					originalAthenaJumpingFallingSpreadMultiplier = AthenaJumpingFallingSpreadMultiplier;
					originalAthenaCrouchingSpreadMultiplier = AthenaCrouchingSpreadMultiplier;
					originalAthenaSprintingSpreadMultiplier = AthenaSprintingSpreadMultiplier;
					originalMinSpeedForSpreadMultiplier = MinSpeedForSpreadMultiplier;
					originalMaxSpeedForSpreadMultiplier = MaxSpeedForSpreadMultiplier;

					Spread = 0.0f;
					SpreadDownsights = 0.0f;
					StandingStillSpreadMultiplier = 0.0f;
					AthenaJumpingFallingSpreadMultiplier = 0.0f;
					AthenaCrouchingSpreadMultiplier = 0.0f;
					AthenaSprintingSpreadMultiplier = 0.0f;
					MinSpeedForSpreadMultiplier = 0.0f;
					MaxSpeedForSpreadMultiplier = 0.0f;
				}

			}
		}
		else if (*(float*)(LocalWeapon + Offsets::FortniteGame::FortWeapon::LastFireAbilityTime) == last_fire_ability_time) {

			last_fire_ability_time = *(float*)(LocalWeapon + Offsets::FortniteGame::FortWeapon::LastFireAbilityTime);
			Spread = originalSpread;
			SpreadDownsights = originalSpreadDownsights;
			StandingStillSpreadMultiplier = originalStandingStillSpreadMultiplier;
			AthenaJumpingFallingSpreadMultiplier = originalAthenaJumpingFallingSpreadMultiplier;
			AthenaCrouchingSpreadMultiplier = originalAthenaCrouchingSpreadMultiplier;
			AthenaSprintingSpreadMultiplier = originalAthenaSprintingSpreadMultiplier;
			MinSpeedForSpreadMultiplier = originalMinSpeedForSpreadMultiplier;
			MaxSpeedForSpreadMultiplier = originalMaxSpeedForSpreadMultiplier;

			return;
		}
	}

	if (bNoSpread)
	{

		uint8_t curweap = 0;
		uint64_t v10 = 0;
		int v11;
		int v25;
		if (!LocalPawn) return;
		curweap = *(uint8_t*)((uintptr_t)LocalPawn + 0x5A0);
		if (curweap) return;
		v10 = *(uint64_t*)(curweap + 0xE6E);
		if (!v10) printf("\nv10 is incorrect."); return;
		v11 = *(int*)(curweap + 0xE6F);
		if (!v11) printf("\nv11 is incorrect.");  return;
		v25 = v11 ^ curweap + ((4 * v10) + 0xE5E);
		if (!v25) printf("\nv25 is incorrect."); return;
		*(float*)v25 = 0.0;
	}

	if (bRapidFire && LocalPawn) {
		Rapid((float)3);
	}
}
